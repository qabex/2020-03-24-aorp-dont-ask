{"version":3,"file":"index.mjs","sources":["../code/utils.jsy","../../js-roap/esm/index.mjs","../code/index.jsy"],"sourcesContent":["export const delay = @\\ ms=1000 => @\n  new Promise @ y =>\n    setTimeout @ y, ms\n\n","async function * as_async_iter(ao_iterable) {\n  yield * ao_iterable;}\n\n\nconst deferred = ((() => {\n  const l=[], lset = l.splice.bind(l, 0, 2);\n  return function deferred(host) {\n    if (undefined === host) {\n      host = this || {reset: deferred};}\n\n    host.promise = new Promise(lset);\n    host.resolve = l[0];\n    host.reject = l[1];\n    return host} })());\n\n\nfunction ao_deferred(init_ao) {\n  const aod = deferred({\n    tip: undefined\n  , valid: false\n  , done: false\n  , reset: deferred});\n\n  aod.init = init_ao({\n    // mirrored async generator protocol\n    update(v) {\n      aod.valid = true;\n      aod.tip = v;\n      aod.resolve(v);\n      return aod.promise}\n\n  , return(v) {\n      aod.done = Promise.resolve(v);\n      aod.resolve();\n      return aod.done}\n\n  , throw(err) {\n      aod.done = Promise.reject(err);\n      aod.resolve();\n      return aod.done} });\n\n  return aod}\n\n\nfunction ao_tee(ao_iter, only_next_) {\n  only_next_ = !! only_next_;\n  ao_iter = as_async_iter(ao_iter);\n\n  const aod = ao_deferred (async ( ao ) => {\n    for await (const tip of ao_iter) {\n      ao.update(tip);\n      aod.reset();} });\n\n  return {\n    ao_iter\n  , ao_tee(only_next=only_next_) {\n      return ao_tee_dispatch(aod, only_next)}\n  , [Symbol.asyncIterator]() {\n      return ao_tee_dispatch(aod, only_next_)} } }\n\n\nasync function * ao_tee_dispatch(aod, only_next) {\n  if (!only_next && aod.valid) {\n    yield aod.tip;}\n\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n    yield aod.tip;} }\n\nasync function ao_watch(...args) {\n  let obj={}, ao_iter, on_update;\n  for (const ea of args) {\n    if ('function' === typeof ea) {\n      on_update = ea;}\n    else if (undefined !== ea[Symbol.asyncIterator] || ea.next) {\n      ao_iter = as_async_iter(ea);}\n    else obj = ea;}\n\n  return _ao_watcher(obj, ao_iter, on_update) }\n\n\nasync function _ao_watcher(obj, ao_iter, on_update) {\n  const {value, done} = await ao_iter.next();\n  obj.value = value;\n  obj.done = done;\n  obj.tail = done ? Promise.resolve(obj)\n    : _ao_watcher(obj, ao_iter, on_update);\n\n  if (undefined !== on_update) {\n    await on_update(value, obj); }\n\n  return obj}\n\nasync function as_ao_watch(arg) {\n  arg = await arg;\n  if (undefined !== arg.tail) {\n    return arg }// already an ao_watch instance\n\n  return await _ao_watcher({}, as_async_iter(arg)) }\n\nfunction _ao_wrap_watcher(_ao_compute_with) {\n  return fn_compute =>\n    _ao_watcher({}, _ao_compute_with(fn_compute)) }\n\nfunction ao_watch_compute_args(...args) {\n  return _ao_wrap_watcher(\n    ao_compute_pos(args) ) }\n\nfunction ao_watch_compute_pos(by_pos) {\n  return _ao_wrap_watcher(\n    ao_compute_pos(by_pos) ) }\n\nfunction ao_watch_compute_kw(by_kw) {\n  return _ao_wrap_watcher(\n    ao_compute_entries(Object.entries(by_kw)) ) }\n\nfunction ao_watch_compute_entries(by_entries) {\n  return _ao_wrap_watcher(\n    ao_compute_entries(by_entries) ) }\n\n\n\nfunction ao_compute_args(...args) {\n  return _ao_compute_with.bind(null,\n    _ao_watch_deps_set(args)\n  , _ao_compute_pos) }\n\nfunction ao_compute_pos(by_pos) {\n  return _ao_compute_with.bind(null,\n    _ao_watch_deps_set(by_pos)\n  , _ao_compute_pos) }\n\nfunction ao_compute_kw(by_kw) {\n  return _ao_compute_with.bind(null,\n    _ao_watch_deps_map(Object.entries(by_kw))\n  , _ao_compute_kw) }\n\nfunction ao_compute_entries(by_entries) {\n  return _ao_compute_with.bind(null,\n    _ao_watch_deps_map(by_entries)\n  , _ao_compute_kw) }\n\n\n\nasync function _ao_watch_deps_set(by_pos) {\n  const watch_deps = new Set();\n  for (const each of by_pos) {\n    watch_deps.add(await as_ao_watch(await each)); }\n  return watch_deps}\n\nasync function _ao_watch_deps_map(by_entries) {\n  const watch_deps = new Map();\n  for (const [name, each] of by_entries) {\n    watch_deps.set(name, await as_ao_watch(await each)); }\n  return watch_deps}\n\n\nasync function _ao_watch_join(watch_deps) {\n  await new Promise (( resolve ) => {\n    for (const d of watch_deps.values()) {\n      d.tail.then(resolve);} }); }\n\nasync function * _ao_compute_with(watch_deps, _ao_compute, fn_compute, only_next) {\n  watch_deps = await watch_deps;\n  if (only_next) {\n    await _ao_watch_join(watch_deps); }\n\n  while (true) {\n    yield _ao_compute(watch_deps, fn_compute);\n    await _ao_watch_join(watch_deps); } }\n\nconst _obj_value = o => o.value;\nfunction _ao_compute_pos(watch_deps, fn_compute) {\n  const deps = Array.from(watch_deps.values(), _obj_value);\n  return fn_compute(... deps)}\n\nfunction _ao_compute_kw(watch_deps, fn_compute) {\n  const deps = {};\n  for (const [k,d] of watch_deps.entries()) {\n    deps[k] = d.value;}\n  return fn_compute(deps)}\n\nasync function * ao_updates(init_ao) {\n  const aod = ao_deferred(init_ao);\n  for await (let xform of aod.init) {\n    if ('function' !== typeof xform) {\n      xform = undefined;}\n\n    yield * ao_dispatch(aod, xform); } }\n\n\nasync function * ao_dispatch(aod, xform) {\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n\n    // grab current v_tip into local const\n    let v_cur = aod.tip;\n    aod.tip = undefined;\n    aod.reset();\n\n    if (undefined !== xform) {\n      v_cur = await xform(v_cur); }\n\n    yield v_cur;} }\n\nfunction ao_dom_events(...args) {\n  return ao_tee(ao_dom_updates(...args)) }\n\nfunction ao_dom_updates(elem, evt_list='input', fn_compute='value') {\n   {\n    if ('string' === typeof elem) {\n      elem = document.querySelector(elem);}\n\n    if ('string' === typeof evt_list) {\n      evt_list = evt_list.split(/\\s+/);}\n\n    if ('string' === typeof fn_compute) {\n      const attr = fn_compute;\n      fn_compute = elem => elem[attr];} }\n\n\n  return ao_updates ((async function * ( ao ) {\n    function _update() {\n      ao.update(elem); }\n\n    for (const evt of evt_list) {\n      elem.addEventListener(evt, _update); }\n\n    try {\n      _update(elem);\n      yield fn_compute;}\n\n    finally {\n      for (const evt of evt_list) {\n        elem.removeEventListener(evt, _update); } } }).bind(this)) }\n\n\nfunction ao_animation_frames() {\n  return ao_updates ((async function * ( ao ) {\n    async function _update(ts) {\n      await ao.update(ts);\n      rid = requestAnimationFrame(_update); }\n\n    let rid = requestAnimationFrame(_update);\n    try {yield;}\n    finally {cancelAnimationFrame(rid);} }).bind(this)) }\n\nfunction ao_pulse_events(...args) {\n  return ao_tee(ao_pulse_updates(...args)) }\n\nfunction ao_pulse_updates(ms) {\n  return ao_updates ((async function * ( ao ) {\n    const ts0 = Date.now();\n    function _update() {\n      ao.update(Date.now() - ts0); }\n\n    const tid = setInterval(_update, ms);\n    try {yield;}\n    finally {clearInterval(tid);} }).bind(this)) }\n\nexport { _ao_compute_kw, _ao_compute_pos, _ao_compute_with, _ao_watch_deps_map, _ao_watch_deps_set, _ao_watch_join, _ao_watcher, _ao_wrap_watcher, ao_animation_frames, ao_compute_kw as ao_compute, ao_compute_args, ao_compute_entries, ao_compute_kw, ao_compute_pos, ao_deferred, ao_dispatch, ao_dom_events as ao_dom, ao_dom_events, ao_dom_updates, ao_pulse_events as ao_pulse, ao_pulse_events, ao_pulse_updates, ao_tee, ao_tee_dispatch, ao_updates, ao_watch, ao_watch_compute_kw as ao_watch_compute, ao_watch_compute_args, ao_watch_compute_entries, ao_watch_compute_kw, ao_watch_compute_pos, as_ao_watch, as_async_iter, deferred };\n//# sourceMappingURL=index.mjs.map\n","import { delay } from './utils.jsy'\nimport @{}\n  ao_dom, ao_pulse,\n  ao_watch_compute\nfrom 'roap'\n\n::!>\n  await document\n\n  const ao_fn = ao_watch_compute @:\n    red: ao_dom @ '#red', 'input', elem => + elem.value\n    green: ao_dom @ '#green', 'input', elem => + elem.value\n    blue: ao_dom @ '#blue', 'input', elem => + elem.value\n    pulse: ao_pulse @ 2000\n\n  const ao_color = await ao_fn @ recompute_color\n  while true ::\n    console.log @ 'tick:', ao_color\n    await delay(15000)\n\n\nasync function recompute_color({red, green, blue, pulse}) ::\n  const color = `rgb(${[0|red, 0|green, 0|blue]})`\n  const e_div = document.querySelector('#output')\n  e_div.style.backgroundColor = color\n  return color\n\n"],"names":[],"mappings":";EACE,YAAa;IACX,WAAY;;ACFhB;EACE;;;AAGF;EACE;EACA;IACE;MACE;;IAEF;IACA;IACA;IACA;;;AAGJ;EACE;IACE;;;;;EAKF;;IAEE;MACE;MACA;MACA;MACA;;;MAGA;MACA;MACA;;;MAGA;MACA;MACA;;EAEJ;;;AAGF;EACE;EACA;;EAEA;IACE;MACE;MACA;;EAEJ;IACE;;MAEE;;MAEA;;;AAGN;EACE;IACE;;EAEF;IACE;IACA;MACE;IACF;;;AAcJ;EACE;EACA;EACA;EACA;;;EAGA;IACE;;EAEF;;AAEF;EACE;EACA;IACE;;EAEF;;AAEF;EACE;IACE;;AAUJ;EACE;IACE;;AAuBJ;EACE;IACE;;;AAWJ;EACE;EACA;IACE;EACF;;;AAGF;EACE;IACE;MACE;;AAEN;EACE;EACA;IACE;;EAEF;IACE;IACA;;AAOJ;EACE;EACA;IACE;EACF;;AAEF;EACE;EACA;IACE,IAAI,UAAU;MACZ;;IAEF;;;AAGJ;EACE;IACE;IACA;MACE;;;IAGF;IACA;IACA;;IAEA;MACE;;IAEF;;AAEJ;EACE;;AAEF,uCAAuC,OAAO,aAAa,OAAO;GAC/D;IACC,IAAI,QAAQ;MACV;;IAEF,IAAI,QAAQ;MACV,0BAA0B,KAAK;;IAEjC,IAAI,QAAQ;MACV;MACA;;;EAGJ;IACE;MACE;;IAEF;MACE;;IAEF;MACE;MACA;;;MAGA;QACE;;AAaR;EACE;;AAEF;EACE;IACE;IACA;MACE;;IAEF;IACA;;;;;EC9PF;;EAEA;IACE,mBAAc,MAAM,EAAE,OAAO;IAC7B,qBAAgB,QAAQ,EAAE,OAAO;IACjC,oBAAe,OAAO,EAAE,OAAO;IAC/B,uBAAiB;;EAEnB,6BAA8B;SACzB;IACH,YAAa,OAAQ;IACrB;;;AAGJ;EACE,cAAc,OAAO,yBAAyB;EAC9C,qCAAqC,SAAS;EAC9C;EACA"}