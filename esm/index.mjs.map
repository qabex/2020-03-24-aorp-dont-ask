{"version":3,"file":"index.mjs","sources":["../code/utils.jsy","../../aorp/esm/index.mjs","../code/index.jsy"],"sourcesContent":["export const delay = @\\ ms=1000 => @\n  new Promise @ y =>\n    setTimeout @ y, ms\n\n","async function * as_async_iter(ao_iterable) {\n  yield * ao_iterable;}\n\n\nconst deferred = ((() => {\n  const l=[], lset = l.splice.bind(l, 0, 2);\n  return function deferred(host) {\n    if (undefined === host) {\n      host = this || {reset: deferred};}\n\n    host.promise = new Promise(lset);\n    host.resolve = l[0];\n    host.reject = l[1];\n    return host} })());\n\n\nfunction ao_deferred(init_ao) {\n  const aod = deferred({\n    tip: undefined\n  , valid: false\n  , done: false\n  , reset: deferred});\n\n  aod.init = init_ao({\n    // mirrored async generator protocol\n    update(v) {\n      aod.valid = true;\n      aod.tip = v;\n      aod.resolve(v);\n      return aod.promise}\n\n  , return(v) {\n      aod.done = Promise.resolve(v);\n      aod.resolve();\n      return aod.done}\n\n  , throw(err) {\n      aod.done = Promise.reject(err);\n      aod.resolve();\n      return aod.done} });\n\n  return aod}\n\n\nfunction ao_tee(ao_iter, only_next_) {\n  only_next_ = !! only_next_;\n  ao_iter = as_async_iter(ao_iter);\n\n  const aod = ao_deferred (async ( ao ) => {\n    for await (const tip of ao_iter) {\n      ao.update(tip);\n      aod.reset();} });\n\n  return {\n    inner: ao_iter\n  , ao_tee(only_next=only_next_) {\n      return ao_tee_dispatch(aod, only_next)}\n  , [Symbol.asyncIterator]() {\n      return ao_tee_dispatch(aod, only_next_)} } }\n\n\nasync function * ao_tee_dispatch(aod, only_next) {\n  if (!only_next && aod.valid) {\n    yield aod.tip;}\n\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n    yield aod.tip;} }\n\nasync function ao_watch(...args) {\n  let obj={}, ao_iter, on_update;\n  for (const ea of args) {\n    if ('function' === typeof ea) {\n      on_update = ea;}\n    else if (undefined !== ea[Symbol.asyncIterator] || ea.next) {\n      ao_iter = as_async_iter(ea);}\n    else obj = ea;}\n\n  return _ao_watcher(obj, ao_iter, on_update) }\n\n\nasync function _ao_watcher(obj, ao_iter, on_update) {\n  const {value, done} = await ao_iter.next();\n  obj.value = value;\n  obj.done = done;\n  obj.tail = done\n    ? Promise.resolve(obj)\n    : _ao_watcher(obj, ao_iter, on_update);\n\n  if (undefined !== on_update) {\n    await on_update(value, obj); }\n\n  return obj}\n\nfunction as_ao_watch(arg) {\n  if (undefined !== arg.tail) {\n    return arg }// already an ao_watch instance\n\n  arg = as_async_iter(arg);\n  return _ao_watcher({}, arg)}\n\nfunction _ao_watch_inner(_ao_compute_with) {\n  return (( fn_compute, on_update ) => {\n    const ao = _ao_compute_with(fn_compute);\n    return _ao_watcher({}, ao, on_update) }) }\n\nfunction ao_watch_compute_args(...args) {\n  return _ao_watch_inner(\n    ao_compute_pos(args) ) }\n\nfunction ao_watch_compute_pos(by_pos) {\n  return _ao_watch_inner(\n    ao_compute_pos(by_pos) ) }\n\nfunction ao_watch_compute_kw(by_kw) {\n  return _ao_watch_inner(\n    ao_compute_entries(\n      Object.entries(by_kw)) ) }\n\nfunction ao_watch_compute_entries(by_entries) {\n  return _ao_watch_inner(\n    ao_compute_entries(by_entries) ) }\n\n\n\nfunction ao_compute_args(...args) {\n  return ao_compute_pos(args) }\n\nfunction ao_compute_pos(by_pos) {\n  const watch_deps = new Set();\n  for (const each of by_pos) {\n    watch_deps.add(as_ao_watch(each)); }\n\n  return _ao_compute_with.bind(null,\n    watch_deps, _ao_compute_pos) }\n\n\nfunction ao_compute_kw(by_kw) {\n  return ao_compute_entries(\n    Object.entries(by_kw)) }\n\nfunction ao_compute_entries(by_entries) {\n  const watch_deps = new Map();\n  for (const [name, each] of by_entries) {\n    watch_deps.set(name, as_ao_watch(each)); }\n\n  return _ao_compute_with.bind(null,\n    watch_deps, _ao_compute_kw) }\n\n\n\n\nasync function ao_watch_join(watch_deps) {\n  await new Promise (( resolve ) => {\n    for (const d of watch_deps.values()) {\n      d.tail.then(resolve);} }); }\n\nasync function * _ao_compute_with(watch_deps, _ao_compute, fn_compute, only_next) {\n  if (only_next) {\n    await ao_watch_join(watch_deps); }\n\n  while (true) {\n    yield _ao_compute(watch_deps, fn_compute);\n    await ao_watch_join(watch_deps); } }\n\nconst _obj_value = o => o.value;\nfunction _ao_compute_pos(watch_deps, fn_compute) {\n  const deps = Array.from(watch_deps.values(), _obj_value);\n  return fn_compute(... deps)}\n\nfunction _ao_compute_kw(watch_deps, fn_compute) {\n  const deps = {};\n  for (const [k,d] of watch_deps.entries()) {\n    deps[k] = d.value;}\n  return fn_compute(deps)}\n\nasync function * ao_updates(init_ao) {\n  const aod = ao_deferred(init_ao);\n  for await (let xform of aod.init) {\n    if ('function' !== typeof xform) {\n      xform = undefined;}\n\n    yield * ao_dispatch(aod, xform); } }\n\n\nasync function * ao_dispatch(aod, xform) {\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n\n    // grab current v_tip into local const\n    let v_cur = aod.tip;\n    aod.tip = undefined;\n    aod.reset();\n\n    if (undefined !== xform) {\n      v_cur = await xform(v_cur); }\n\n    yield v_cur;} }\n\nfunction ao_dom_events(...args) {\n  return ao_tee(ao_dom_updates(...args)) }\n\nfunction ao_dom_updates(elem, evt_list='input', fn_compute='value') {\n   {\n    if ('string' === typeof elem) {\n      elem = document.querySelector(elem);}\n\n    if ('string' === typeof evt_list) {\n      evt_list = evt_list.split(/\\s+/);}\n\n    if ('string' === typeof fn_compute) {\n      const attr = fn_compute;\n      fn_compute = elem => elem[attr];} }\n\n\n  return ao_updates ((async function * ( ao ) {\n    function _update() {\n      ao.update(elem); }\n\n    for (const evt of evt_list) {\n      elem.addEventListener(evt, _update); }\n\n    try {\n      _update(elem);\n      yield fn_compute;}\n\n    finally {\n      for (const evt of evt_list) {\n        elem.removeEventListener(evt, _update); } } }).bind(this)) }\n\n\nfunction ao_animation_frames() {\n  return ao_updates ((async function * ( ao ) {\n    async function _update(ts) {\n      await ao.update(ts);\n      rid = requestAnimationFrame(_update); }\n\n    let rid = requestAnimationFrame(_update);\n    try {yield;}\n    finally {cancelAnimationFrame(rid);} }).bind(this)) }\n\nexport { _ao_compute_kw, _ao_compute_pos, _ao_compute_with, _ao_watcher, ao_animation_frames, ao_compute_kw as ao_compute, ao_compute_args, ao_compute_entries, ao_compute_kw, ao_compute_pos, ao_deferred, ao_dispatch, ao_dom_events as ao_dom, ao_dom_events, ao_dom_updates, ao_tee, ao_tee_dispatch, ao_updates, ao_watch, ao_watch_compute_kw as ao_watch_compute, ao_watch_compute_args, ao_watch_compute_entries, ao_watch_compute_kw, ao_watch_compute_pos, ao_watch_join, as_ao_watch, as_async_iter, deferred };\n//# sourceMappingURL=index.mjs.map\n","import { delay } from './utils.jsy'\nimport @{}\n  ao_dom, ao_watch\n  ao_compute\n  ao_watch_compute\nfrom 'aorp'\n\nconst ao_bango = ao_dom @ '#bango', 'input', elem => + elem.value\nconst ao_bingo = ao_dom @ '#bingo', 'input', elem => + elem.value\nconst ao_bongo = ao_dom @ '#bongo', 'input', elem => + elem.value\n\nasync function trial_a() ::\n  let ao_fn\n\n  if 1 ::\n    const bango = await ao_watch @ ao_bango, v => console.log @: bango: v\n    const bingo = await ao_watch @ ao_bingo, v => console.log @: bingo: v\n    const bongo = await ao_watch @ ao_bongo, v => console.log @: bongo: v\n\n    ao_fn = ao_watch_compute @:\n      bango\n      bingo\n      bongo\n  else ::\n    ao_fn = ao_watch_compute @:\n      bango: ao_bango\n      bingo: ao_bingo\n      bongo: ao_bongo\n\n  const ao_v = await ao_fn @ awesome\n\n  while true ::\n    console.log @ ao_v\n    await delay(1000)\n\n\nasync function awesome({bango, bingo, bongo}) ::\n  const color = `rgb(${[bango, bingo, bongo]})`\n  const e_div = document.querySelector('#output')\n  e_div.style.backgroundColor = color\n  return color\n\nPromise.resolve().then @ trial_a\n"],"names":[],"mappings":";EACE,YAAa;IACX,WAAY;;ACFhB;EACE;;;AAGF;EACE;EACA;IACE;MACE;;IAEF;IACA;IACA;IACA;;;AAGJ;EACE;IACE;;;;;EAKF;;IAEE;MACE;MACA;MACA;MACA;;;MAGA;MACA;MACA;;;MAGA;MACA;MACA;;EAEJ;;;AAGF;EACE;EACA;;EAEA;IACE;MACE;MACA;;EAEJ;IACE;;MAEE;;MAEA;;;AAGN;EACE;IACE;;EAEF;IACE;IACA;MACE;IACF;;AAEJ;EACE;EACA;IACE,IAAI,UAAU;MACZ;;MAEA;;;EAGJ;;;AAGF;EACE;EACA;EACA;EACA;;;;EAIA;IACE;;EAEF;;AAEF;EACE;IACE;;EAEF;EACA;;AAEF;EACE;IACE;IACA;;AAUJ;EACE;IACE;MACE;;AAwBN;EACE;EACA;IACE;;EAEF;IACE;;;;;AAKJ;EACE;IACE;MACE;;AAEN;EACE;IACE;;EAEF;IACE;IACA;;AAOJ;EACE;EACA;IACE;EACF;;AAEF;EACE;EACA;IACE,IAAI,UAAU;MACZ;;IAEF;;;AAGJ;EACE;IACE;IACA;MACE;;;IAGF;IACA;IACA;;IAEA;MACE;;IAEF;;AAEJ;EACE;;AAEF,uCAAuC,OAAO,aAAa,OAAO;GAC/D;IACC,IAAI,QAAQ;MACV;;IAEF,IAAI,QAAQ;MACV,0BAA0B,KAAK;;IAEjC,IAAI,QAAQ;MACV;MACA;;;EAGJ;IACE;MACE;;IAEF;MACE;;IAEF;MACE;MACA;;;MAGA;QACE;;ACjOR,+BAA0B,QAAQ,EAAE,OAAO;AAC3C,+BAA0B,QAAQ,EAAE,OAAO;AAC3C,+BAA0B,QAAQ,EAAE,OAAO;;AAE3C;EACE;;;IAGE,6BAA8B,4BAA8B;IAC5D,6BAA8B,4BAA8B;IAC5D,6BAA8B,4BAA8B;;IAE5D;MACE;MACA;MACA;;EAOJ,yBAA0B;;SAErB;IACH,YAAa;IACb;;;AAGJ;EACE,cAAc,OAAO,sBAAsB;EAC3C,qCAAqC,SAAS;EAC9C;EACA;;AAEF,uBAAwB"}