{"version":3,"file":"index.mjs","sources":["../code/utils.jsy","../../js-roap/esm/index.mjs","../code/index.jsy"],"sourcesContent":["export const delay = @\\ ms=1000 => @\n  new Promise @ y =>\n    setTimeout @ y, ms\n\n","async function * as_ao_iter(ao_iterable) {\n  if (undefined !== ao_iterable.tail) {\n    ao_iterable = ao_tail_obj(ao_iterable);}\n\n  yield * ao_iterable;}\n\nasync function * ao_tail_obj(ao_obj) {\n  if (undefined === ao_obj) {ao_obj = this;}\n\n  while (ao_obj && true !== ao_obj.done) {\n    yield ao_obj.value;\n    ao_obj = await ao_obj.tail;} }\n\nfunction is_ao_iterable(v) {\n  if (undefined !== v[Symbol.asyncIterator] || v.next || v.tail) {\n    return true}\n  return false}\n\n\nconst deferred = ((() => {\n  const l=[], lset = l.splice.bind(l, 0, 2);\n  return function deferred(host) {\n    if (undefined === host) {\n      host = this || {reset: deferred};}\n\n    host.promise = new Promise(lset);\n    host.resolve = l[0];\n    host.reject = l[1];\n    return host} })());\n\n\nfunction ao_deferred(init_ao) {\n  const aod = deferred({\n    tip: undefined\n  , valid: false\n  , done: false\n  , reset: deferred});\n\n  aod.init = init_ao({\n    // mirrored async generator protocol\n    update(v) {\n      aod.valid = true;\n      aod.tip = v;\n      aod.resolve(v);\n      return aod.promise}\n\n  , return(v) {\n      aod.done = Promise.resolve(v);\n      aod.resolve();\n      return aod.done}\n\n  , throw(err) {\n      aod.done = Promise.reject(err);\n      aod.resolve();\n      return aod.done} });\n\n  return aod}\n\n\nfunction ao_tee(ao_iter, only_next_) {\n  only_next_ = !! only_next_;\n  ao_iter = as_ao_iter(ao_iter);\n\n  const aod = ao_deferred (async ( ao ) => {\n    for await (const tip of ao_iter) {\n      ao.update(tip);\n      aod.reset();} });\n\n  return {\n    ao_iter\n  , ao_tee(only_next=only_next_) {\n      return ao_tee_dispatch(aod, only_next)}\n  , [Symbol.asyncIterator]() {\n      return ao_tee_dispatch(aod, only_next_)} } }\n\n\nasync function * ao_tee_dispatch(aod, only_next) {\n  if (!only_next && aod.valid) {\n    yield aod.tip;}\n\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n    yield aod.tip;} }\n\nconst ao_watch_obj0 ={\n  [Symbol.asyncIterator]: ao_tail_obj};\n\nasync function ao_watch(...args) {\n  let ao_obj={__proto__: ao_watch_obj0}, ao_iter, on_update;\n  for (const ea of args) {\n    if ('function' === typeof ea) {\n      on_update = ea;}\n    else if (is_ao_iterable(ea)) {\n      ao_iter = as_ao_iter(ea);}\n    else ao_obj = ea;}\n\n  return _ao_walker(ao_obj, ao_iter, on_update) }\n\n\nasync function _ao_walker(ao_obj, ao_iter, on_update) {\n  const {value, done} = await ao_iter.next();\n  ao_obj.value = value;\n  ao_obj.done = done;\n  ao_obj.tail = done ? Promise.resolve(ao_obj)\n    : _ao_walker(ao_obj, ao_iter, on_update);\n\n  if (undefined !== on_update) {\n    ao_obj.value = await on_update(value, ao_obj); }\n\n  return ao_obj}\n\nasync function as_ao_watch(arg) {\n  arg = await arg;\n  if (undefined !== arg && null !== arg) {\n    if (undefined !== arg.tail) {\n      return arg }// already an ao_watch instance\n\n    if (is_ao_iterable(arg)) {\n      return await _ao_walker(\n        {__proto__: ao_watch_obj0}\n      , as_ao_iter(arg)) } }\n\n  return {value: arg, done: true} }\n\nconst _e_value = e => e.value;\n\nfunction ao_track_updates_kw(kw) {\n  kw = Object.entries(kw);\n  return _ao_track_updates_kw(ao_deps_map(kw)) }\n\nfunction ao_track_updates_map(by_entries) {\n  return _ao_track_updates_kw(ao_deps_map(by_entries)) }\n\nasync function * _ao_track_updates_kw(watch_deps) {\n  watch_deps = await watch_deps;\n\n  while (true) {\n     {\n      const deps = {};\n      for (const e of watch_deps.entries()) {\n        deps[e[0]] = e[1].value;}\n\n      yield deps;}\n\n    await _ao_await_any_dep(watch_deps.values()); } }\n\nasync function ao_deps_map(by_entries) {\n  const watch_deps = new Map();\n  for (const [name, each] of by_entries) {\n    watch_deps.set(name, await as_ao_watch(each)); }\n  return watch_deps}\n\n\n\nfunction ao_track_updates_args(... args) {\n  return _ao_track_updates_pos(ao_deps_pos(args)) }\n\nfunction ao_track_updates_pos(by_pos) {\n  return _ao_track_updates_pos(ao_deps_pos(by_pos)) }\n\nasync function * _ao_track_updates_pos(watch_deps) {\n  watch_deps = await watch_deps;\n\n  while (true) {\n     {\n      const deps = Array.from(watch_deps, _e_value);\n      yield deps;}\n\n    await _ao_await_any_dep(watch_deps); } }\n\nasync function ao_deps_pos(by_pos) {\n  const watch_deps = [];\n  for (const each of by_pos) {\n    watch_deps.push(await as_ao_watch(each)); }\n  return watch_deps}\n\n\n\nasync function _ao_await_any_dep(iter_deps) {\n  await new Promise (( resolve ) => {\n    for (const {tail} of iter_deps) {\n      if (undefined !== tail) {\n        tail.then(resolve);} } }); }\n\nfunction ao_track_kw(kw) {\n  return ao_tee(ao_track_updates_kw(kw)) }\nfunction ao_track_map(by_entries) {\n  return ao_tee(ao_track_updates_map(by_entries)) }\nfunction ao_track_args(... args) {\n  return ao_tee(ao_track_updates_args(... args)) }\nfunction ao_track_pos(by_pos) {\n  return ao_tee(ao_track_updates_pos(by_pos)) }\n\nasync function * ao_updates(init_ao) {\n  const aod = ao_deferred(init_ao);\n  for await (let xform of aod.init) {\n    if ('function' !== typeof xform) {\n      xform = undefined;}\n\n    yield * ao_dispatch(aod, xform); } }\n\n\nasync function * ao_dispatch(aod, xform) {\n  while (true) {\n    await aod.promise;\n    if (false !== aod.done) {\n      return await aod.done}\n\n    // grab current v_tip into local const\n    let v_cur = aod.tip;\n    aod.tip = undefined;\n    aod.reset();\n\n    if (undefined !== xform) {\n      v_cur = await xform(v_cur); }\n\n    yield v_cur;} }\n\nconst _en_click = ['click'];\nconst _en_input = ['input', 'change'];\nconst _e_no_default = e => e.preventDefault();\nconst _opt_unpack = ({text, value}) =>({text, value});\nconst _dom_std_args ={\n  _:[_en_click]\n, 'input':[_en_input, _e_value]\n, 'output':[_en_input, _e_value]\n, 'input,number':[_en_input, e => e.valueAsNumber]\n, 'input,range':[_en_input, e => e.valueAsNumber]\n, 'input,button':[_en_click, _e_value]\n, 'input,submit':[_en_click, _e_value]\n, 'input,checkbox':[_en_input, e => e.checked]\n, 'input,radio':[_en_input, e => e.checked]\n, 'input,date':[_en_input, e => e.valueAsDate]\n, 'input,time':[_en_input, e => e.valueAsNumber]\n, 'input,file':[_en_input, e => e.multiple ? e.files : e.files[0]]\n, 'textarea':[_en_input, _e_value]\n, 'select':{\n      evt_names: _en_input\n    , on_evt(e) {\n        const res = Array.from(e.selectedOptions, _opt_unpack);\n        return e.multiple ? res : res[0]} }\n\n, 'form':{\n      evt_names: _en_input\n    , on_evt: e => new FormData(e)\n    , on_add(e) {e.addEventListener('submit', _e_no_default);} } };\n\n\nfunction _dom_builtin(std, elem) {\n  let {tagName: tag, type} = elem;\n  tag = tag.toLowerCase();\n\n  const res =\n    type && std[`${tag},${type.toLowerCase()}`]\n    || std[tag] || std._;\n\n  return Array.isArray(res)\n    ?{elem, evt_names: res[0], on_evt: res[1]}\n    :{elem, ... res} }\n\n\nfunction _dom_unpack_args(std, elem, args) {\n  if ('string' === typeof elem) {\n    elem = document.querySelector(elem);}\n\n  return args && args.length\n    ?{elem, evt_names: args[0], on_evt: args[1]}\n    : _dom_builtin(std, elem)}\n\n\n\nconst _dom_std_unpack_args = \n  _dom_unpack_args.bind(null, _dom_std_args);\n\nfunction ao_dom_events(elem, ...args) {\n  return ao_tee(_ao_dom_updates(\n    _dom_std_unpack_args(elem, args)) ) }\n\nfunction ao_dom_updates(elem, ...args) {\n  return _ao_dom_updates(\n    _dom_std_unpack_args(elem, args)) }\n\n\n\nfunction _ao_dom_updates({elem, evt_names, on_evt, on_calc, on_add, on_remove}) {\n  if (!Array.isArray(evt_names)) {\n    evt_names = (evt_names || 'click').split(/\\s+/);}\n\n  const extra = on_evt || {};\n  if ('function' !== typeof on_evt) {\n    on_evt = extra.on_evt;}\n\n  return ao_updates ((async function * ( ao ) {\n    const _update = on_evt\n      ? evt => ao.update(on_evt(elem, evt))\n      : ()=> ao.update(elem);\n\n    if (extra.on_add) {\n      extra.on_add(elem);}\n\n    for (const e of evt_names) {\n      elem.addEventListener(e, _update); }\n\n    try {\n      _update(elem);\n      yield extra.on_calc;}\n\n    finally {\n      for (const e of evt_names) {\n        elem.removeEventListener(e, _update); }\n\n      if (extra.on_remove) {\n        extra.on_remove(elem);} } }).bind(this)) }\n\n\nfunction ao_animation_frames() {\n  return ao_updates ((async function * ( ao ) {\n    async function _update(ts) {\n      await ao.update(ts);\n      rid = requestAnimationFrame(_update); }\n\n    let rid = requestAnimationFrame(_update);\n    try {yield;}\n    finally {cancelAnimationFrame(rid);} }).bind(this)) }\n\nconst delay = (...args) =>\n  new Promise(y =>\n    setTimeout(y, ...args) );\n\nfunction ao_pulse_events(...args) {\n  return ao_tee(ao_pulse_updates(...args)) }\n\nfunction ao_pulse_updates(ms, immediate) {\n  return ao_updates ((async function * ( ao ) {\n    const ts0 = Date.now();\n    function _update() {\n      ao.update(Date.now() - ts0); }\n\n    const tid = setInterval(_update, ms);\n    try {\n      if (immediate) {\n        _update();}\n      yield;}\n    finally {clearInterval(tid);} }).bind(this)) }\n\nexport { _ao_await_any_dep, _ao_dom_updates, _ao_track_updates_kw, _ao_track_updates_pos, _ao_walker, _dom_builtin, _dom_std_args, _dom_std_unpack_args, _dom_unpack_args, ao_animation_frames, ao_deferred, ao_deps_map, ao_deps_pos, ao_dispatch, ao_dom_events as ao_dom, ao_dom_events, ao_dom_updates, ao_pulse_events as ao_pulse, ao_pulse_events, ao_pulse_updates, ao_tail_obj, ao_tee, ao_tee_dispatch, ao_track_args, ao_track_kw, ao_track_map, ao_track_pos, ao_track_updates_args, ao_track_updates_kw, ao_track_updates_map, ao_track_updates_pos, ao_updates, ao_watch, as_ao_iter, as_ao_watch, deferred, delay, is_ao_iterable };\n//# sourceMappingURL=index.mjs.map\n","import { delay } from './utils.jsy'\nimport @{}\n  ao_dom, ao_watch, ao_track_kw\nfrom 'roap'\n\nconst dom_loaded = new Promise @ resolve =>\n  window.addEventListener @ 'DOMContentLoaded', resolve\n\n::!>\n  await dom_loaded\n\n  const ao_deps = ao_track_kw @:\n    red: ao_dom @ '#red'\n    green: ao_dom @ '#green'\n    blue: ao_dom @ '#blue'\n\n  const ao_color = await ao_watch @ ao_deps,\n    @\\: red, green, blue =>\n      `rgb(${[0|red, 0|green, 0|blue]})`\n\n  const e_div = document.querySelector('#target')\n  ao_watch @ ao_color, color =>\n    e_div.style.backgroundColor = color\n\n  ::!>\n    while true ::\n      console.log @ 'tick:', ao_color.value\n      await delay(1500)\n\n\nasync function recompute_color({red, green, blue, pulse, e_div}) ::\n  const color = `rgb(${[0|red, 0|green, 0|blue]})`\n  e_div.style.backgroundColor = color\n  return color\n"],"names":[],"mappings":";EACE,YAAa;IACX,WAAY;;ACFhB;EACE;IACE;;EAEF;;AAEF;EACE;;EAEA;IACE;IACA;;AAEJ;EACE;IACE;EACF;;;AAGF;EACE;EACA;IACE;MACE;;IAEF;IACA;IACA;IACA;;;AAGJ;EACE;IACE;;;;;EAKF;;IAEE;MACE;MACA;MACA;MACA;;;MAGA;MACA;MACA;;;MAGA;MACA;MACA;;EAEJ;;;AAGF;EACE;EACA;;EAEA;IACE;MACE;MACA;;EAEJ;IACE;;MAEE;;MAEA;;;AAGN;EACE;IACE;;EAEF;IACE;IACA;MACE;IACF;;AAEJ;EACE;;AAEF;EACE;EACA;IACE,IAAI,UAAU;MACZ;;MAEA;;;EAGJ;;;AAGF;EACE;EACA;EACA;EACA;;;EAGA;IACE;;EAEF;;AAEF;EACE;EACA;IACE;MACE;;IAEF;MACE;QACE;;;EAGN;;AAEF;;AAEA;EACE;EACA;;AAKF;EACE;;EAEA;KACG;MACC;MACA;QACE;;MAEF;;IAEF;;AAEJ;EACE;EACA;IACE;EACF;;;;AA4BF;EACE;IACE;MACE;QACE;;AAER;EACE;AACF;AAOA;EACE;EACA;IACE,IAAI,UAAU;MACZ;;IAEF;;;AAGJ;EACE;IACE;IACA;MACE;;;IAGF;IACA;IACA;;IAEA;MACE;;IAEF;;AAEJ,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO,EAAE,QAAQ;AACpC;AACA;AACA;EACE;AACF,EAAE,OAAO;AACT,EAAE,QAAQ;AACV,EAAE,cAAc;AAChB,EAAE,aAAa;AACf,EAAE,cAAc;AAChB,EAAE,cAAc;AAChB,EAAE,gBAAgB;AAClB,EAAE,aAAa;AACf,EAAE,YAAY;AACd,EAAE,YAAY;AACd,EAAE,YAAY;AACd,EAAE,UAAU;AACZ,EAAE,QAAQ;MACJ;;QAEE;QACA;;AAER,EAAE,MAAM;MACF;;oCAE8B,QAAQ;;;AAG5C;EACE;EACA;;EAEA;IACE,YAAY,GAAG,IAAI,GAAG,mBAAmB,CAAC;;;EAG5C;;;;;AAKF;EACE,IAAI,QAAQ;IACV;;EAEF;;;;;;AAMF;EACE;;AAEF;EACE;IACE;;;;AAQJ;EACE;IACE,0BAA0B,OAAO,QAAQ,KAAK;;EAEhD;EACA,IAAI,UAAU;IACZ;;EAEF;IACE;;;;IAIA;MACE;;IAEF;MACE;;IAEF;MACE;MACA;;;MAGA;QACE;;MAEF;QACE;;;ACrTR,+BAAgC;EAC9B,wBAAyB,kBAAmB;;;EAG5C;;EAEA;IACE,mBAAa;IACb,qBAAe;IACf,oBAAc;;EAEhB,gCAAiC;;MAE7B,OAAO,yBAAyB;;EAEpC,qCAAqC,SAAS;EAC9C,SAAU;IACR;;;WAGK;MACH,YAAa,OAAQ;MACrB"}